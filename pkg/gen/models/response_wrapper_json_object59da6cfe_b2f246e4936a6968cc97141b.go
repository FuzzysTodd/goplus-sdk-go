// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141b ResponseWrapper«JSONObject»-59da6cfe-b2f2-46e4-936a-6968cc97141b
//
// swagger:model ResponseWrapper«JSONObject»-59da6cfe-b2f2-46e4-936a-6968cc97141b
type ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141b struct {

	// Code 1：Success
	Code int32 `json:"code,omitempty"`

	// Response message
	Message string `json:"message,omitempty"`

	// result
	Result *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult `json:"result,omitempty"`
}

// Validate validates this response wrapper JSON object 59da6cfe b2f2 46e4 936a 6968cc97141b
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141b) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateResult(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141b) validateResult(formats strfmt.Registry) error {
	if swag.IsZero(m.Result) { // not required
		return nil
	}

	if m.Result != nil {
		if err := m.Result.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("result")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this response wrapper JSON object 59da6cfe b2f2 46e4 936a 6968cc97141b based on the context it is used
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141b) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateResult(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141b) contextValidateResult(ctx context.Context, formats strfmt.Registry) error {

	if m.Result != nil {
		if err := m.Result.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("result")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141b) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141b) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141b
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult Response result
//
// swagger:model ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult
type ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult struct {

	// It describes the average price of the NFT in 24h.
	AveragePrice24h float64 `json:"average_price_24h,omitempty"`

	// It describes the number of blocks created for the NFT.
	// Return “null” means that we didn't find the number of blocks created for the NFT.
	CreateBlockNumber int64 `json:"create_block_number,omitempty"`

	// It describes the creator address of the NFT.
	// Example: "creator_address": "0x1ee0af784b96bb55ece98c9b15675726b0da1b6b";
	// Return “null” means that we didn't find the creator address.
	CreatorAddress string `json:"creator_address,omitempty"`

	// It describes the discord url of the NFT.
	// Return “null” means there is no discord url or didn't find the discord url.
	DiscordURL string `json:"discord_url,omitempty"`

	// It describes the github url of the NFT.
	// Return “null” means there is no github url or didn't find the github url.
	GithubURL string `json:"github_url,omitempty"`

	// It describes the highest price of the NFT.
	HighestPrice float64 `json:"highest_price,omitempty"`

	// It describes the lowest price of the NFT in 24h.
	LowestPrice24h float64 `json:"lowest_price_24h,omitempty"`

	// It describes whether this NFT has performed malicious behaviors.
	// "1" means true;
	// "0" means false.(Notice:Malicious behaviors include random additions, blacklist abuse, falsified transactions, and other high-risk behaviors. Interacting with NFTs flagged as Malicious may contain a high level of risk)
	MaliciousNftContract int32 `json:"malicious_nft_contract,omitempty"`

	// It describes the medium url of the NFT.
	// Return “null” means there is no medium url or didn't find the medium url.
	MediumURL string `json:"medium_url,omitempty"`

	// metadata_frozen
	MetadataFrozen int32 `json:"metadata_frozen,omitempty"`

	// It describes the introduction of the NFT.
	// Return “null” means there is no description of the NFT.
	NftDescription string `json:"nft_description,omitempty"`

	// It describes the ERC protocol of the NFT.
	// Example: "nft_erc": "erc721"
	NftErc string `json:"nft_erc,omitempty"`

	// It describes the numbers of the NFT.
	NftItems int64 `json:"nft_items,omitempty"`

	// nft_name
	NftName string `json:"nft_name,omitempty"`

	// It describes whether this contract is open source.
	// "1" means true;
	// "0" means false.(Notice:Un-open-sourced contracts may hide various unknown mechanisms and are extremely risky. When the contract is not open source, we will not be able to detect other risk items.)
	NftOpenSource int32 `json:"nft_open_source,omitempty"`

	// It describes the holders of the NFT.
	NftOwnerNumber float64 `json:"nft_owner_number,omitempty"`

	// It describes whether this NFT contract has a proxy contract.
	// "1" means true;
	// "0" means false;
	// "Null" means unknown.(Notice:(1) When "is_open_source": "0", it will return "null".
	// (2) Most Proxy contracts are accompanied by modifiable implementation contracts, and implementation contracts may contain significant potential risk.)
	NftProxy int32 `json:"nft_proxy,omitempty"`

	// nft_symbol
	NftSymbol string `json:"nft_symbol,omitempty"`

	// It describes whether the NFT is verified.
	// "1" means that the NFT is verified;
	// "0" means that we did not find any information about whether the NFT is verified.
	NftVerified int32 `json:"nft_verified,omitempty"`

	// It describes whether this NFT owner can bypass the maximum amount of minting specified in the contract, and continue to mint NFTs beyond this limit.
	// "1" means true;
	// "0" means false;
	// "Null" means unknown.(Notice:Oversupply minting refers to the existence of a special mint method in the NFT contract — the owner can bypass the maximum amount of minting specified in the contract, and continue to mint NFTs beyond this limit.)
	OversupplyMinting int32 `json:"oversupply_minting,omitempty"`

	// privileged burn
	PrivilegedBurn *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedBurn `json:"privileged_burn,omitempty"`

	// privileged minting
	PrivilegedMinting *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedMinting `json:"privileged_minting,omitempty"`

	// red check mark
	RedCheckMark int32 `json:"red_check_mark,omitempty"`

	// It describes whether the NFT contract can restrict the approval, resulting in NFT can not be traded on the NFT DEX.
	// "1" means true;
	// "0" means false;
	// "Null" means unknown.(Notice:If this risk exists, it means that users will not be able to trade the NFT on the exchange and only privileged users in the whitelist will be able to trade normally.)
	RestrictedApproval int32 `json:"restricted_approval,omitempty"`

	// It describes the sales of the NFT in 24h.
	Sales24h float64 `json:"sales_24h,omitempty"`

	// It describes the info of other NFTs with duplicate name and symbol.
	SameNfts []*ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSameNftsItems0 `json:"same_nfts"`

	// self destruct
	SelfDestruct *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSelfDestruct `json:"self_destruct,omitempty"`

	// It describes the telegram url of the NFT.
	// Return “null” means there is no telegram url or didn't find the telegram url.
	TelegramURL string `json:"telegram_url,omitempty"`

	// token_id
	TokenID string `json:"token_id,omitempty"`

	// It describes the total volume of the NFT.
	TotalVolume float64 `json:"total_volume,omitempty"`

	// It describes the trading volume of the NFT in 24h.
	TradedVolume24h float64 `json:"traded_volume_24h,omitempty"`

	// transfer without approval
	TransferWithoutApproval *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultTransferWithoutApproval `json:"transfer_without_approval,omitempty"`

	// It describes whether the NFT is a famous and trustworthy one.
	// "1" means true;
	// Return "null" means no result.(Notice:(1) Only "trust_list": "1" means it is a famous and trustworthy NFT.
	// (2) Return "null" doesn't mean it is risky.Th)
	TrustList int32 `json:"trust_list,omitempty"`

	// It describes the twitter url of the NFT.
	// Return “null” means there is no twitter url or didn't find the twitter url.
	TwitterURL string `json:"twitter_url,omitempty"`

	// It describes the website url of the NFT.
	// Return “null” means there is no website url or didn't find the website url.
	WebsiteURL string `json:"website_url,omitempty"`
}

// Validate validates this response wrapper JSON object59da6cfe b2f246e4936a6968cc97141b result
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePrivilegedBurn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrivilegedMinting(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSameNfts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfDestruct(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransferWithoutApproval(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult) validatePrivilegedBurn(formats strfmt.Registry) error {
	if swag.IsZero(m.PrivilegedBurn) { // not required
		return nil
	}

	if m.PrivilegedBurn != nil {
		if err := m.PrivilegedBurn.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result" + "." + "privileged_burn")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("result" + "." + "privileged_burn")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult) validatePrivilegedMinting(formats strfmt.Registry) error {
	if swag.IsZero(m.PrivilegedMinting) { // not required
		return nil
	}

	if m.PrivilegedMinting != nil {
		if err := m.PrivilegedMinting.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result" + "." + "privileged_minting")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("result" + "." + "privileged_minting")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult) validateSameNfts(formats strfmt.Registry) error {
	if swag.IsZero(m.SameNfts) { // not required
		return nil
	}

	for i := 0; i < len(m.SameNfts); i++ {
		if swag.IsZero(m.SameNfts[i]) { // not required
			continue
		}

		if m.SameNfts[i] != nil {
			if err := m.SameNfts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("result" + "." + "same_nfts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("result" + "." + "same_nfts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult) validateSelfDestruct(formats strfmt.Registry) error {
	if swag.IsZero(m.SelfDestruct) { // not required
		return nil
	}

	if m.SelfDestruct != nil {
		if err := m.SelfDestruct.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result" + "." + "self_destruct")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("result" + "." + "self_destruct")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult) validateTransferWithoutApproval(formats strfmt.Registry) error {
	if swag.IsZero(m.TransferWithoutApproval) { // not required
		return nil
	}

	if m.TransferWithoutApproval != nil {
		if err := m.TransferWithoutApproval.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result" + "." + "transfer_without_approval")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("result" + "." + "transfer_without_approval")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this response wrapper JSON object59da6cfe b2f246e4936a6968cc97141b result based on the context it is used
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePrivilegedBurn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePrivilegedMinting(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSameNfts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelfDestruct(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTransferWithoutApproval(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult) contextValidatePrivilegedBurn(ctx context.Context, formats strfmt.Registry) error {

	if m.PrivilegedBurn != nil {
		if err := m.PrivilegedBurn.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result" + "." + "privileged_burn")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("result" + "." + "privileged_burn")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult) contextValidatePrivilegedMinting(ctx context.Context, formats strfmt.Registry) error {

	if m.PrivilegedMinting != nil {
		if err := m.PrivilegedMinting.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result" + "." + "privileged_minting")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("result" + "." + "privileged_minting")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult) contextValidateSameNfts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.SameNfts); i++ {

		if m.SameNfts[i] != nil {
			if err := m.SameNfts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("result" + "." + "same_nfts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("result" + "." + "same_nfts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult) contextValidateSelfDestruct(ctx context.Context, formats strfmt.Registry) error {

	if m.SelfDestruct != nil {
		if err := m.SelfDestruct.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result" + "." + "self_destruct")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("result" + "." + "self_destruct")
			}
			return err
		}
	}

	return nil
}

func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult) contextValidateTransferWithoutApproval(ctx context.Context, formats strfmt.Registry) error {

	if m.TransferWithoutApproval != nil {
		if err := m.TransferWithoutApproval.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("result" + "." + "transfer_without_approval")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("result" + "." + "transfer_without_approval")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResult
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedBurn It describes whether the NFT owner can burn others NFT.(Notice:Privileged_burn means that the owner can burn others' NFTs directly through the method.)
//
// swagger:model ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedBurn
type ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedBurn struct {

	// Owner_address describes the owner address.
	// null: the owner address cannot be fetched.
	OwnerAddress string `json:"owner_address,omitempty"`

	// "blackhole" : the owner is a blackhole address.
	// "contract" : the owner is a contract.
	// "eoa" : the owner is a common address (eoa).
	// "multi-address": the owner is an array/list.
	// null: the address is not detected.
	OwnerType string `json:"owner_type,omitempty"`

	// The "value" describes the status of the risk.
	// null: the contract is not open source or there is a proxy, it is not possible to detect whether the risk exists. -1: the risk is detected but the ownership give up. If the detection of a code vulnerability, it can also be considered risk-free.
	// 0: the risk is not detected.
	// 1: the risk is detected, and the owner address is a common address (EOA), then it can be said that there is a clear risk.
	// 2: The risk is detected, but the owner address is a contract address, the risk is not significant.
	// 3: The risk is detected, but the owner address is not detectable / or an array.
	//
	Value int32 `json:"value,omitempty"`
}

// Validate validates this response wrapper JSON object59da6cfe b2f246e4936a6968cc97141b result privileged burn
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedBurn) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this response wrapper JSON object59da6cfe b2f246e4936a6968cc97141b result privileged burn based on context it is used
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedBurn) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedBurn) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedBurn) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedBurn
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedMinting It describes whether the NFT contract has  minting methods which can only be triggered by an address with special privileges.
// (Notice:Some minting methods can only be triggered by an address with special privileges. Generally speaking, these are usually for the owner to mint.)
//
// swagger:model ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedMinting
type ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedMinting struct {

	// Owner_address describes the owner address.
	// null: the owner address cannot be fetched.
	OwnerAddress string `json:"owner_address,omitempty"`

	// "blackhole" : the owner is a blackhole address.
	// "contract" : the owner is a contract.
	// "eoa" : the owner is a common address (eoa).
	// "multi-address": the owner is an array/list.
	// null: the address is not detected.
	OwnerType string `json:"owner_type,omitempty"`

	// The "value" describes the status of the risk.
	// null: the contract is not open source or there is a proxy, it is not possible to detect whether the risk exists. -1: the risk is detected but the ownership give up. If the detection of a code vulnerability, it can also be considered risk-free.
	// 0: the risk is not detected.
	// 1: the risk is detected, and the owner address is a common address (EOA), then it can be said that there is a clear risk.
	// 2: The risk is detected, but the owner address is a contract address, the risk is not significant.
	// 3: The risk is detected, but the owner address is not detectable / or an array.
	//
	Value int32 `json:"value,omitempty"`
}

// Validate validates this response wrapper JSON object59da6cfe b2f246e4936a6968cc97141b result privileged minting
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedMinting) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this response wrapper JSON object59da6cfe b2f246e4936a6968cc97141b result privileged minting based on context it is used
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedMinting) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedMinting) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedMinting) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultPrivilegedMinting
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSameNftsItems0 response wrapper JSON object59da6cfe b2f246e4936a6968cc97141b result same nfts items0
//
// swagger:model ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSameNftsItems0
type ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSameNftsItems0 struct {

	// describes the number of blocks created for the NFT.
	// Return "null" means no NFTs with duplicate name and symbol.
	CreateBlockNumber int64 `json:"create_block_number,omitempty"`

	// It describes the address of the NFTs;
	NftAddress string `json:"nft_address,omitempty"`

	// It describes the name of the NFT;
	NftName string `json:"nft_name,omitempty"`

	// It describes the holders of the NFT;
	NftOwnerNumber int64 `json:"nft_owner_number,omitempty"`

	// It describes the symbol of the NFT;
	NftSymbol string `json:"nft_symbol,omitempty"`
}

// Validate validates this response wrapper JSON object59da6cfe b2f246e4936a6968cc97141b result same nfts items0
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSameNftsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this response wrapper JSON object59da6cfe b2f246e4936a6968cc97141b result same nfts items0 based on context it is used
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSameNftsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSameNftsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSameNftsItems0) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSameNftsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSelfDestruct { value: owner_address: owner_type }It describes whether this NFT contract can self destruct.
// (Notice:When the self-destruct function is triggered, this contract will be destroyed, all functions will be unavailable, and all related assets will be erased.)
//
// swagger:model ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSelfDestruct
type ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSelfDestruct struct {

	// Owner_address describes the owner address.
	// null: the owner address cannot be fetched.
	OwnerAddress string `json:"owner_address,omitempty"`

	// "blackhole" : the owner is a blackhole address.
	// "contract" : the owner is a contract.
	// "eoa" : the owner is a common address (eoa).
	// "multi-address": the owner is an array/list.
	// null: the address is not detected.
	OwnerType string `json:"owner_type,omitempty"`

	// The "value" describes the status of the risk.
	// null: the contract is not open source or there is a proxy, it is not possible to detect whether the risk exists. -1: the risk is detected but the ownership give up. If the detection of a code vulnerability, it can also be considered risk-free.
	// 0: the risk is not detected.
	// 1: the risk is detected, and the owner address is a common address (EOA), then it can be said that there is a clear risk.
	// 2: The risk is detected, but the owner address is a contract address, the risk is not significant.
	// 3: The risk is detected, but the owner address is not detectable / or an array.
	//
	Value int32 `json:"value,omitempty"`
}

// Validate validates this response wrapper JSON object59da6cfe b2f246e4936a6968cc97141b result self destruct
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSelfDestruct) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this response wrapper JSON object59da6cfe b2f246e4936a6968cc97141b result self destruct based on context it is used
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSelfDestruct) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSelfDestruct) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSelfDestruct) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultSelfDestruct
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultTransferWithoutApproval It describes whether the NFT owner can transfer NFT without approval.(Notice:Transfer_without_approval generally means the scammer does not need to get approvals to transfer another address's NFT.
// One typical example is sleep_minting. Sleep_minting means that the scammer will first add the NFT to a well-known wallet address and then retrieve the NFT. After the value of the NFT has appreciated , it will be put back on the market.)
//
// swagger:model ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultTransferWithoutApproval
type ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultTransferWithoutApproval struct {

	// Owner_address describes the owner address.
	// null: the owner address cannot be fetched.
	OwnerAddress string `json:"owner_address,omitempty"`

	// "blackhole" : the owner is a blackhole address.
	// "contract" : the owner is a contract.
	// "eoa" : the owner is a common address (eoa).
	// "multi-address": the owner is an array/list.
	// null: the address is not detected.
	OwnerType string `json:"owner_type,omitempty"`

	// The "value" describes the status of the risk.
	// null: the contract is not open source or there is a proxy, it is not possible to detect whether the risk exists. -1: the risk is detected but the ownership give up. If the detection of a code vulnerability, it can also be considered risk-free.
	// 0: the risk is not detected.
	// 1: the risk is detected, and the owner address is a common address (EOA), then it can be said that there is a clear risk.
	// 2: The risk is detected, but the owner address is a contract address, the risk is not significant.
	// 3: The risk is detected, but the owner address is not detectable / or an array.
	//
	Value int32 `json:"value,omitempty"`
}

// Validate validates this response wrapper JSON object59da6cfe b2f246e4936a6968cc97141b result transfer without approval
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultTransferWithoutApproval) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this response wrapper JSON object59da6cfe b2f246e4936a6968cc97141b result transfer without approval based on context it is used
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultTransferWithoutApproval) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultTransferWithoutApproval) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultTransferWithoutApproval) UnmarshalBinary(b []byte) error {
	var res ResponseWrapperJSONObject59da6cfeB2f246e4936a6968cc97141bResultTransferWithoutApproval
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
